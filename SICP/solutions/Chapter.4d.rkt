#lang racket

; ========== E4.41
(define (solve-4.41)
  (define (satisfy? solution)
    (let ((baker (car solution))
          (cooper (cadr solution))
          (fletcher (caddr solution))
          (miller (cadddr solution))
          (smith (car (cddddr solution))))
      (and (not (= baker 5))
           (not (= cooper 1))
           (not (= fletcher 5))
           (not (= fletcher 1))
           (> miller cooper)
           (not (= (abs (- smith fletcher)) 1))
           (not (= (abs (- fletcher cooper)) 1)))))
  (define (flatmap proc l)
    (if (null? l)
        '()
        (append (proc (car l))
                (flatmap proc (cdr l)))))
  (define (permutation lst)
    (if (null? lst)
        '(())
        (flatmap (lambda (x)
                   (map (lambda (y)
                          (cons x y))
                        (permutation (remove x lst))))
                 lst)))
  (define (print solution)
    (list (list 'baker (car solution))
          (list 'cooper (cadr solution))
          (list 'fletcher (caddr solution))
          (list 'miller (cadddr solution))
          (list 'smith (car (cddddr solution)))))
  (map print (filter satisfy? (permutation '(1 2 3 4 5)))))
